<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="XPort.API">
<Super>Frontier.Router</Super>
<TimeCreated>64583,57726.057897</TimeCreated>

<Parameter name="UseSession">
<Default>1</Default>
</Parameter>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/xport</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/ping" Method="HEAD" UseAuth="false" Call="Ping"/>
<Route Url="/info" Method="GET" UseAuth="false" Call="GetAPIInfo" />
<Map Prefix="/namespaces/:namespace/projects" Forward="XPort.API.Projects"/>
<Map Prefix="/namespaces/:namespace/documents" Forward="XPort.API.Documents"/>
</Routes>
]]></Data>
</XData>

<Method name="OnSetup">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim %frontier As Frontier.Context

  // Disables path normalization and tries to resolve using the received path syntax.
  set ^||Port.Internals.Configuration("remote") = 1

  set %frontier.PropertyFormatter = ##class(Frontier.PropertyFormatter.SnakeCase).%New()

  set basicStrategy = ##class(Frontier.Authentication.BasicStrategy).%New({
   "realm": "source",
   "validator": ($classname()_":ValidateCredentials")
  })

  do %frontier.CORS.Default()
  $$$QuitOnError(%frontier.AuthenticationManager.AddStrategy(basicStrategy))

  return $$$OK
]]></Implementation>
</Method>

<Method name="ValidateCredentials">
<ClassMethod>1</ClassMethod>
<FormalSpec>login:%String,password:%String,*found:%Boolean=1,*httpStatus:%String,*user:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set found = $System.Security.Login(login, password)
  if 'found {
    set httpStatus = ..#HTTP403FORBIDDEN
    return $$$ERROR($$$InvalidUsernameOrPassword)
  }

  if '$System.Security.CheckUserPermission(login, "%Development", "USE") {
    set httpStatus = ..#HTTP403FORBIDDEN
    return $$$ERROR($$$RequiresRoleForConnection, "%Development")
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Ping">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return ""
]]></Implementation>
</Method>

<Method name="GetAPIInfo">
<ClassMethod>1</ClassMethod>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set name = ##class(XPort.Installer).#NAME
  
  new $namespace
  set $namespace = "%SYS"
  
  do ##class(Security.Applications).Get(name, .d)
  
  return {
    "version": ("0.9.1"),
    "application": (name),
    "namespace": (d("NameSpace")),
    "dispatcher": (d("DispatchClass"))
  }
]]></Implementation>
</Method>
</Class>


<Class name="XPort.API.Documents">
<IncludeCode>portutils</IncludeCode>
<Super>Frontier.Router</Super>
<TimeCreated>65101,34629.058077</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/xport</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/find" Method="GET" UseAuth="true" Call="FindDocuments"/>
<Route Url="/raw/?(.*)?" Strict="false" UseAuth="false" Method="GET" Call="GetRawFile"/>
<Route Url="/preview/?(.*)?" Strict="false" Method="GET" Call="PreviewDocument" />
<Route Url="/references" Method="GET" Call="GetDocumentReferences" />
</Routes>
]]></Data>
</XData>

<Method name="GetRawFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set path = $$GetWebApplicationServingPath(.webApp)
  return %frontier.Files.ServeFile(path)
  
GetWebApplicationServingPath(webApp)
  // Makes sure we don't fetch the /public part
  set match = $$$LPadProvidedSlash(%frontier.Matches(1), "/")
  if $extract(match, 1, 7) = "/public" set match = $replace(match, "/public", "") 
  
  new $namespace
  set $namespace = "%SYS"
  
  set r = ##class(%SQL.Statement).%ExecDirect(, "SELECT TOP 1 Path, Name FROM SECURITY.APPLICATIONS WHERE NAMESPACE = ? AND PATH IS NOT NULL AND ? %STARTSWITH NAME ORDER BY LENGTH(PATH) DESC", namespace, match)
  
  if r.%Next(.sc) {
    $$$ThrowOnError(sc) 
    set appName = r.%Get("Name") 
    set appPath = r.%Get("Path")
    return appPath_$replace(match, appName, "")
  }  
  return ""
]]></Implementation>
</Method>

<Method name="FindDocuments">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,pattern:%String,limit:%Integer=50</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set s = ##class(%SQL.Statement).%New()
  $$$ThrowOnError(s.%PrepareClassQuery("%RoutineMgr", "StudioOpenDialog"))
  set c = s.%Execute(pattern,,,1,1)

  set matches = []
  set hits = 0

  set appPath = ""

  while c.%Next(.sc) {
    $$$ThrowOnError(sc)

    if hits > limit quit
    set hits = hits + 1

    set name = c.%Get("Name")
    set type = c.%Get("Type")

    if type = 9 || (type = 7) continue

    do matches.%Push(name)
  }

  return { "matches": (matches) }
]]></Implementation>
</Method>

<Method name="PreviewDocument">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set match = $$$LPadProvidedSlash(%frontier.Matches(1), "/")
  set itemName = ##class(Port.Util).PathToItem(match, namespace)
  set code = ##class(XPort.Util.NamespaceCall).RetrieveItemSourceCode(namespace, itemName, .binary)
  set ext = $piece(itemName, ".", *)  
  return { "binary": ($$$FormatBoolean(binary)), "preview": (code) }
]]></Implementation>
</Method>

<Method name="GetDocumentReferences">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,expression:%String,pattern:%String,includeSystemDocs:%Boolean=1,wholeWords:%Boolean=0,caseSensitive:%Boolean=0,max:%Integer=50,filter:%String="",wild:%Boolean=0</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set references = []
  $$$ThrowOnError(##class(Frontier.Shared.Utilities).CallAndCapture("%Studio.Project", "FindInFiles", .output, expression, pattern, includeSystemDocs, wholeWords, caseSensitive, max, filter, wild))

  while 'output.AtEnd {
    set line = output.ReadLine()
    if line = "" continue
    do references.%Push(line)
  }
  return { "references": (references) }
]]></Implementation>
</Method>
</Class>


<Class name="XPort.API.Projects">
<IncludeCode>xport</IncludeCode>
<Super>Frontier.Router</Super>
<TimeCreated>65105,55524.872927</TimeCreated>

<XData name="UrlMap">
<XMLNamespace>http://github.com/rfns/xport</XMLNamespace>
<Data><![CDATA[
<Routes>
<Route Url="/" Method="GET" Call="ListProjects" />
<Route Url="/:project" Method="DELETE" Call="DeleteProject" />
<Route Url="/:project/create" Method="POST" Call="CreateProject"/>
<Route Url="/:project/xml" Method="GET" Call="GetProjectXML" />
<Route Url="/:project/compile" Method="POST" Call="CompileProject" />
<Route Url="/:project/repair" Method="PATCH" Call="RepairProject" />
<Map Prefix="/:project/items" Forward="XPort.API.Projects.Items"/>
</Routes>
]]></Data>
</XData>

<Method name="GetProjectXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[  return { "xml": (##class(XPort.Util.NamespaceCall).ExportProjectToXML(namespace, project)) }
]]></Implementation>
</Method>

<Method name="ListProjects">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[  return ##class(XPort.Util.NamespaceCall).ListProjects(namespace)
]]></Implementation>
</Method>

<Method name="DeleteProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  do ##class(XPort.Util.NamespaceCall).DeleteProject(namespace, project)

  return {
    "deleted": true
  }
]]></Implementation>
</Method>

<Method name="CompileProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String,options:%String="cku",legacySourceControl:%Boolean=0</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set options = options_"/nodisplayerror"
  $$$CheckLegacySourceControl(legacySourceControl)

  set sc = ##class(Frontier.Shared.Utilities).CallAndCapture("XPort.Util.NamespaceCall", "CompileProject", .output, namespace, project, options)
  $$$ThrowOnError(##class(XPort.Util.DynamicStatus).ToDynamicObject(sc, .error))

  set log = []
  set errors = []

  if $isobject(error) {
    if 'error.%IsA("%DynamicArray") set errors = [(error)]
  }

  if $$$ISOK(sc) && $isobject(output) {
    while 'output.AtEnd {
      set line = output.ReadLine()
      if $extract(line, 1, 2) = ", " set line = $extract(line, 3, *)
      if line '= "" do log.%Push(line)
    }
  }

  return {
    "errors": (errors),
    "log": (log)
  }
]]></Implementation>
</Method>

<Method name="RepairProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  do ##class(XPort.Util.NamespaceCall).RepairProject(namespace, project)
  do %frontier.Status(..#HTTP204NOCONTENT)
  return { "repaired": true }
]]></Implementation>
</Method>
</Class>


<Class name="XPort.API.Projects.Items">
<IncludeCode>portutils,xport</IncludeCode>
<Super>Frontier.Router</Super>
<TimeCreated>65105,55682.252423</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
  <Route Url="/sources/pick"  Method="POST" Call="PickItemSources"/>
  <Route Url="/sources/list"  Method="GET" Call="ListItemSources"/>
  <Route Url="/count"  Method="GET" Call="CountItemSources"/>
  <Route Url="/publish" Method="POST" Call="PublishItems"/>
  <Route Url="/remove" Method="POST" Call="RemoveItems"/>
  <Route Url="/delete" Method="POST" Call="DeleteItems"/>
  <Route Url="/paths" Method="GET" Call="GetItemPaths"/>
</Routes>
]]></Data>
</XData>

<Method name="DeleteItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,projectName:%String(ALIAS="project"),items:%DynamicArray</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set project = ##class(XPort.Util.NamespaceCall).GetProject(namespace, projectName)

  set iSC = $$$OK

  set errorOnDelete = []
  set successOnDelete = []

  for i=0:1:items.%Size() - 1 {
    try {
      set sourcePath = items.%Get(i)

      set itemName = ##class(Port.Util).PathToItem(sourcePath, namespace)
      set type = ##class(Port.Util).GetPathType(sourcePath)
      if itemName = "" $$$ThrowStatus($$$ERROR($$$GeneralError, "Could not resolve item name using path "_sourcePath))

      set conflicts = ##class(Port.Util).ListConflicts(project.Name, itemName, type)
      if conflicts '= "" $$$ThrowStatus($$$ERROR($$$GeneralError, "Cannot delete the item "_itemName_" because it's associated to another project. Please check if the following projects depend on it: "_$lts(conflicts, ", ")))

      set routine = ##class(%RoutineMgr).%New(itemName)

      if '$isobject(routine) {
        $$$ThrowStatus($$$ERROR($$$GeneralError, "Cannot delete the item: "_itemName_ " because it doesn't exist on the server."))
      } elseif type = "PUBLIC" {
        set path = routine.Code.Filename
        $$$ThrowOnError(routine.Delete(itemName))
        $$$ThrowOnError(##class(XPort.Util.FileRemover).RemoveOne(path))
      } else {
        $$$ThrowOnError(routine.Delete(itemName))
      }
      do successOnDelete.%Push(itemName)
    } catch ex {
      set error = ##class(Frontier.Exception).ToDynamicObject(ex)
      set error.itemName = itemName
      do errorOnDelete.%Push(error)
    }
  }

  $$$ThrowOnError(project.Check())
  $$$ThrowOnError(project.%Save())

  set result = {
    "success": (successOnDelete),
    "hasErrors": ($select(errorOnDelete.%Size() > 0 : "true", 1: "false")),
    "failure": {
      "header": "Failed to delete some items: ",
      "items": (errorOnDelete)
    }
  }
  return result
]]></Implementation>
</Method>

<Method name="RemoveItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String,payload:%DynamicArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

  set project = ##class(XPort.Util.NamespaceCall).GetProject(namespace, project)

  set successOnRemove = []
  set errorOnRemove = []

  for i=0:1:payload.%Size() - 1 {
    try {
      set sourcePath = payload.%Get(i)
      set itemName = ##class(Port.Util).PathToItem(sourcePath, namespace)
      $$$ThrowOnError(project.RemoveItem(itemName))
      do successOnRemove.%Push(itemName)
    } catch ex {
      set error = ##class(Frontier.Exception).ToDynamicObject(ex)
      set error.itemName = itemName
      do errorOnRemove.%Push(error)
    }
  }

  $$$ThrowOnError(project.%Save())

  set result = {
    "success": (successOnRemove),
    "hasErrors": ($select(errorOnRemove.%Size() > 0 : "true", 1: "false")),
    "failure": {
      "header": ("Failed to remove "_errorOnRemove.%Size()_" items"),
      "items": (errorOnRemove)
    }
  }

  return result
]]></Implementation>
</Method>

<Method name="PublishItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String,payload:%DynamicObject,callLegacySourceControl:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set project = ##class(XPort.Util.NamespaceCall).GetProject(namespace, project, 1)

  set errorOnPublish = []
  set publishedItems = []
  set compileList = ""
  set compileErrors = ""
  set sc = $$$OK

  set warning = ""
  set sc = $$$ERROR($$$GeneralError, "No valid item has been found.")

  if '$isobject(project) {
    set projectName = %frontier.RouteParameters("project")
    set project = ##class(XPort.Util.NamespaceCall).CreateProject(namespace, projectName)    
    set warning = $$$FormatText("Project %1 did not exist so it was created.", projectName)    
  }

  set payloadIterator = payload.items.%GetIterator()

  while payloadIterator.%GetNext(.i, .file) {
    try {
      set sc = $$$OK
      set source = ""
      set itemName = ##class(Port.Util).PathToItem(file.path, namespace)
      set type = ##class(Port.Util).GetPathType(file.path)
      set itemType = ##class(Port.Util).GetItemType(itemName)
      set fileName = ##class(%File).GetFilename(file.path)
      set binary = 0

      if itemName = "" $$$ThrowStatus($$$ERROR($$$GeneralError, "Could not resolve the origin '"_file.path_"' to a valid item name. Are you sure that '"_fileName_"' is a valid '"_type_"' type?"))

      set conflicts = ##class(Port.Util).ListConflicts(project.Name, itemName)
      if conflicts '= "" $$$ThrowStatus($$$PERROR($$$CannotSaveConflictingItems, itemName, $lts(conflicts), project.Name))

      set itemId = ##class(Port.Util).ResolveItemId(itemName, project.Name)
      set itemExists = project.Items.IsDefined(itemId)
      set code = file.content

      if '$isobject(code) $$$ThrowStatus($$$ERROR($$$GeneralError, "'content' array was not provided for "_itemName))
      set iterator = code.%GetIterator()

      while iterator.%GetNext(.key, .line) {
        set source(0) = key + 1        
        set source(source(0)) = line
      }      

      do ##class(XPort.Util.NamespaceCall).SetItemLock(namespace, itemName, 1)

      $$$CheckLegacySourceControl(callLegacySourceControl)

      if ##class(Port.Util).IsRoutine(itemName) || (itemType = "CSP") {
        set routine = ##class(XPort.Util.NamespaceCall).GetRoutine(namespace, itemName)
        set extension = $$$ucase($piece(itemName, ".", *))
        
        if '$isobject(routine) $$$ThrowStatus($$$ERROR($$$GeneralError, "Invalid item name."))

        if itemType = "CSP" {          
          set binary = $select(file.%IsDefined("binary") : file.binary, 1: ##class(XPort.Util.NamespaceCall).IsBinary(extension))
          set routine.Code.TranslateTable = ##class(Port.Configuration).GetPublicFileInputTranslateTable()
          
          if binary = 1 {
            set routine.Code.TranslateTable = "RAW"
            set routine.Code.StreamFormatWrite = 0
          }
          
          if extension = "CSP" || (extension = "CSR") {
            set compileList(itemName) = ""
          }
        } else {
          set compileList(itemName) = ""
        }

        $$$ThrowOnError($$WriteToStream(routine.Code))
        $$$ThrowOnError(routine.%Save())
      } elseif type = "CLS" {
        // Both the file name and the class name must match.
        $$$ThrowOnError($$AssertClassDefinitionMatch(itemName))

        set stream = ##class(%Stream.GlobalCharacter).%New()
        $$$ThrowOnError($$WriteToStream(stream))

        $$$ThrowOnError(##class(%Compiler.UDL.TextServices).SetTextFromStream(namespace, itemName_".CLS", stream))
        set compileList(itemName) = ""
      }

      if $order(compileList("")) '= "" {
        $$$ThrowOnError(##class(XPort.Util.NamespaceCall).CompileList(namespace, .compileList, payload.compilerOptions))
      }
      
      do ##class(XPort.Util.NamespaceCall).AddItem(namespace, project.Name, itemName)      
      
      if binary = 1 set code = []
      else  set code = ##class(XPort.Util.NamespaceCall).RetrieveItemSourceCode(namespace, itemName)

      do publishedItems.%Push({
        "name": (itemName),
        "content": (code),
        "path": (file.path)
      })
    } catch ex {
      set error = ##class(Frontier.Exception).ToDynamicObject(ex)
      set error.itemName = itemName
      do errorOnPublish.%Push(error)
    }

    do ##class(XPort.Util.NamespaceCall).SetItemLock(namespace, itemName, 0)
  }

  return {
    "success": (publishedItems),
    "hasErrors": ($select(errorOnPublish.%Size() > 0 : "true", 1: "false")),
    "warning": ($case(warning, "": "null", : warning)),
    "failure": {
      "header": "Failed to publish the following items: ",
      "items": (errorOnPublish)
    }
  }

WriteToStream(stream)
  set sc = $$$OK
  do stream.Clear()   

  for i=1:1:source(0) {
    if 'binary {      
      set chunk = $zstrip(source(i), "*C'W",, $c(10,13,9))
      $$$ReturnOnError(stream.WriteLine(chunk))
    } else {
      set chunk = $System.Encryption.Base64Decode(source(i))
      $$$ReturnOnError(stream.Write(chunk))
    }
  }
  do stream.Rewind()
  return $$$OK

AssertClassDefinitionMatch(className)
  for c=1:1:source(0) {
    if $$$lcase($extract(source(c), 1, 6)) = "class " {
      set definingClass = $piece(source(c), " ", 2, 2)
      set className = $piece(className, ".", 1, *-1)

      if definingClass '= className {
        // We cannot allow a class that mismatches its own name to be saved.
        return $$$ERROR($$$GeneralError, $$$FormatText("Attempt to define class named '%1' while the file name is '%2'. Both item and class names must match.", definingClass, className))
      }
      return $$$OK
    }
  }
  if c = source(0) return $$$ERROR($$$GeneralError, $$$FormatText("Item '%1' is not a valid class.", className))
  return $$$OK
]]></Implementation>
</Method>

<Method name="GetItemPaths">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
  // 999999 Because a single project wouldn't have almost one million of files and this is still faster than
  // using a preload strategy because it avoids roundtrips.
  set list = ##class(XPort.Util.NamespaceCall).ListProjectItems(namespace, project, 1, 999999)
  set paths = []
  
  for i=0:1:list.items.%Size() - 1 {
    set item = list.items.%Get(i)
    set ext = $$$ucase($piece(item.name, ".", *))
    set externalPath = $replace(##class(Port.Util).ItemToPath(item.name), "\", "/")        
    do paths.%Push({ "path": (externalPath), "binary": ($$$FormatBoolean(item.binary)), "name": (item.name) })
  }
  return { "paths": (paths) }
]]></Implementation>
</Method>

<Method name="ListItemSources">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String,page:%Integer=1,size:%Integer=50</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set project = ##class(XPort.Util.NamespaceCall).GetProject(namespace, project)   
  
  set list = ##class(XPort.Util.NamespaceCall).ListProjectItems(namespace, project.Name, page, size)
  
  set result = { 
    "success": [],
    "failure": {
      "header": "Failed to get the sources from the following items: ",
      "items": []
    }  
  }  
  
  for i=0:1:list.items.%Size() - 1 {
    set current = list.items.%Get(i)
    set name = current.name
    set index = current.index
   
    try {
      set file = ##class(Port.Util).ItemToPath(name)
      set code = ##class(XPort.Util.NamespaceCall).RetrieveItemSourceCode(namespace, name, .binary)
      
      do result.success.%Push({
        "index": (index),
        "name": (name),
        "content": (code),
        "path": ($$$LTrimSlash(file)),
        "fileName": (##class(%File).GetFilename(file))
      })      
    } catch ex {
      set error = ##class(Frontier.Exception).ToDynamicObject(ex)
      set error.itemName = name
      do result.failure.items.%Push(error)
    }
  }
  
  if list.errors.%Size() > 0 {
    for i=0:1:list.errors.%Size() - 1 {
      set error = list.errors.%Get(i)
      set error.itemName = name
      do result.failure.items.%Push(error)
    }
  }
  
  set result.hasErrors = $$$FormatBoolean(result.failure.items.%Size() > 0)
  set result.more = $$$FormatBoolean(list.more)
  return result
]]></Implementation>
</Method>

<Method name="PickItemSources">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String,payload:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
 
  set project = ##class(XPort.Util.NamespaceCall).GetProject(namespace, project)
  
  set result = { 
    "success": [],
    "failure": {
      "header": "Failed to get the sources from the following items: ",
      "items": []
    }  
  }  

  for i=0:1:payload.files.%Size() - 1 {
    try {
      set filePath = payload.files.%Get(i)           
      set itemName = ##class(Port.Util).PathToItem(filePath, namespace)
      set fileBelongsToProject = ##class(Port.Util).ExistsInProject(project.Name, itemName, "", namespace)
      
      if 'fileBelongsToProject {
        $$$ThrowStatus($$$ERROR($$$GeneralError, "Item "_itemName_" is not present in the project '"_%frontier.RouteParameters("project")_"' or does not exist."))
      }
      
      set code = ##class(XPort.Util.NamespaceCall).RetrieveItemSourceCode(namespace, itemName, .binary)

      do result.success.%Push({
        "name": (itemName),
        "content": (code),
        "path": ($$$LTrimSlash(filePath)),
        "fileName": (##class(%File).GetFilename(filePath))
      })
    } catch ex {
      set error = ##class(Frontier.Exception).ToDynamicObject(ex)
      set error.itemName = itemName
      do result.failure.items.%Push(error)
    }
  }
  
  set result.hasErrors = $$$FormatBoolean((result.failure.items.%Size() > 0))
  return result
]]></Implementation>
</Method>

<Method name="CountItemSources">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,project:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
  set count = ##class(XPort.Util.NamespaceCall).CountProjectItems(namespace, project)
  return { "count": (count) }
]]></Implementation>
</Method>
</Class>


<Class name="XPort.Util.DynamicStatus">
<Abstract>1</Abstract>
<TimeCreated>65106,33092.700976</TimeCreated>

<Method name="ToDynamicObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>status:%Status,*error:%DynamicObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK

  try {
    if $$$ISERR(status) {
      set exception = ##class(Frontier.Exception).CreateFromStatus(status)
      set error = ##class(Frontier.Exception).ToDynamicObject(exception)
      if $isobject(error) {
        if error.error '= "" set error = error.error        
        if error.errors '= "" set error = error.errors
      }
    }
  } catch err {
    set sc = err.AsStatus()
  }

  return sc
]]></Implementation>
</Method>
</Class>


<Class name="XPort.Util.FileRemover">
<Description>
This utility is used to handle file deletions from the server along with removing empty directories left by them.</Description>
<IncludeCode>portutils</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64744,50300.86048</TimeCreated>

<Property name="Entries">
<Type>%String</Type>
<Collection>list</Collection>
</Property>

<Property name="Statement">
<Type>%SQL.Statement</Type>
</Property>

<Property name="AppPathCache">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Statement = ##class(%SQL.Statement).%New()
  do ..Statement.%PrepareClassQuery("%File", "FileSet")
  return $$$OK
]]></Implementation>
</Method>

<Method name="AddFileToRemoval">
<FormalSpec>filePath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ..Entries.Insert(##class(%File).NormalizeFilename(filePath))
]]></Implementation>
</Method>

<Method name="Run">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  for i=1:1:..Entries.Count() {
    set filePath = ..Entries.GetAt(i)
    set sc = ..Remove(filePath)
    if $$$ISERR(sc) return sc
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Remove">
<FormalSpec>path:%String,hasContent:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  if path = ..GetWebApplicationPath(path) return $$$OK 
  
  // There's a bug when using Exists for directories, it seems to assume that a directory is also a file.
  // To workaround this, DirectoryExists is also applied because it WILL return 0.
  if '##class(%File).DirectoryExists(path) && ##class(%File).Exists(path) { 
    do ##class(%File).Delete(path) 
  } elseif hasContent = 0 { 
    do ##class(%File).RemoveDirectory(path)
  }
    
  set path = $piece(path, $$$OSSlash, 1, *-1)
  set r = ..Statement.%Execute(path)
  set hasContent = 0
    
  if r.%Next(.sc) {
    if $$$ISERR(sc) return sc
    set hasContent = 1
  }  
  return ..Remove(path, hasContent)
]]></Implementation>
</Method>

<Method name="RemoveOne">
<ClassMethod>1</ClassMethod>
<FormalSpec>filePath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set remover = ..%New()
  $$$QuitOnError(remover.AddFileToRemoval(filePath))
  return remover.Run()
]]></Implementation>
</Method>

<Method name="GetWebApplicationPath">
<FormalSpec>filePath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
     
  if ..AppPathCache '= "" return ..AppPathCache
  
  new $namespace 
  set $namespace = "%SYS"
  
  set rows = ##class(%SQL.Statement).%ExecDirect(, "SELECT TOP 1 Path FROM SECURITY.APPLICATIONS WHERE ? %STARTSWITH Path ORDER BY LEN(PATH) DESC", filePath)
  if rows.%Next() {
    set path = ##class(%File).NormalizeFilename(rows.%Get("Path"))
    set ..AppPathCache = path
    return path
  }
  return ""
]]></Implementation>
</Method>
</Class>


<Class name="XPort.Util.NamespaceCall">
<Abstract>1</Abstract>
<IncludeCode>xport,frontier,portutils</IncludeCode>
<TimeCreated>64754,39701.20307</TimeCreated>

<Method name="IsBinary">
<ClassMethod>1</ClassMethod>
<FormalSpec>ext:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set ext = $$$ucase(ext)
  if $lf($lfs($$$RoutineGroups_",MD,CSP,CSR,SCSS,LESS,JSX,VUE,CLS,JSON"), ext) return 0
  do ##class(%CSP.StreamServer).FileClassify(ext, .type, .binary)
  return binary
]]></Implementation>
</Method>

<Method name="SetItemLock">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,itemName:%String,lock:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  return ##class(%RoutineMgr).LockItem(itemName, lock)
]]></Implementation>
</Method>

<Method name="CompileList">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[namespace:%String,&compileList:%String="",qspec:%String="cku"]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  set compileErrors = 0

  set sc = $$$OK

  do $System.OBJ.CompileList(.compileList, qspec_"/nodisplay", .compileErrors)

  if compileErrors > 0 {
    for c=1:1:compileErrors {
      set sc = $$$ADDSC(sc, $$$ERROR(compileErrors(c, "code"), compileErrors(c)))
    }
    $$$QuitOnError(sc)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="GetRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,routineName:%String</FormalSpec>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  set routine = ##class(%RoutineMgr).%OpenId(routineName)
  if '$isobject(routine) set routine = ##class(%RoutineMgr).%New(routineName)

  return routine
]]></Implementation>
</Method>

<Method name="DeleteItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,itemName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  return ##class(%RoutineMgr).Delete(itemName)
]]></Implementation>
</Method>

<Method name="ListProjects">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)

  set projects = []

  set s = ##class(%SQL.Statement).%New()
  $$$ThrowOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectList"))
  set c = s.%Execute()

  while c.%Next() {
    set name = c.%Get("Name")
    if name [ "Default" continue
    &sql(SELECT TOP 1 NAME into :item FROM %STUDIO.PROJECTITEM WHERE PROJECT = :name)
    set hasItems = $select(item '= "" : "true", 1: "false")
    do projects.%Push({ "name": (name), "has_items": (hasItems) })
  }

  return {
    "projects": (projects)
  }
]]></Implementation>
</Method>

<Method name="CountProjectItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,projectName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  
  set count = 0
  set ts = ##class(%SQL.Statement).%ExecDirect(, "call %Studio.Project_ProjectItemsList(?)", projectName)
  while ts.%Next() { set count = count + 1 }
  
  return count
]]></Implementation>
</Method>

<Method name="ListProjectItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,projectName:%String,page:%Integer=1,size:%Integer=50</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  
  set items = []

  set s = ##class(%SQL.Statement).%New()
  $$$ThrowOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))  
  set r = s.%Execute(projectName)
  
  set count = ..CountProjectItems(namespace, projectName)   
  
  set result = { "items": [], "errors": [] } 
  set i = 0
  
  // Calculates the page boundaries.
  set limit = page * size
  set offset = limit - (size - 1)

  while r.%Next(.sc) {
    set i = i + 1        
    if i < offset continue
    if i > limit quit
    
    try {                  
      $$$ThrowOnError(sc)      
      
      set name = r.%Get("Name")
      set type = r.%Get("Type")
      set ext = $$$ucase($piece(name, ".", *))
      
      // We are expanding the PKGs already because only the classes matter.
      if type = "PKG" continue      
      
      $$$ThrowOnError(##class(%Studio.Project).NormalizeName(.name, .type))    
      if type = "CLS" set name = name_".cls" set ext = "CLS"
      do result.items.%Push({ "index": (i), "name": (name), "binary": (..IsBinary(ext)) })
    } catch ex {
      set error = ##class(Frontier.Exception).ToDynamicObject(ex)
      do result.errors.%Push({ "index": (i), "error": (error) })
    }
  }
  
  do result.%Set("more", i < count, "boolean")
  return result
]]></Implementation>
</Method>

<Method name="GetProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,ignoreError:%Boolean=0</FormalSpec>
<ReturnType>%Studio.Project</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)

  set project = ##class(%Studio.Project).%OpenId(name)
  if $isobject(project) do project.Items.Load()
  if 'ignoreError $$$ThrowOnError(..AssertValidProject(name))  
  return project
]]></Implementation>
</Method>

<Method name="AddItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,itemName:%String</FormalSpec>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  
  set project = ..GetProject(namespace, name)
  
  set sc = project.AddItem(itemName)
  
  if $$$GETERRORCODE(sc) '= $$$ProjectIncludesPackage {
    // We don't care if class is owned by a package or not, if that's the error we ignore it.
    $$$ThrowOnError(sc)
  }
  
  $$$ThrowOnError(project.%Save())
]]></Implementation>
</Method>

<Method name="CreateProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%Studio.Project</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  
  // Checks if the project exists to prevent ID clashes.
  set project = ##class(%Studio.Project).%OpenId(namespace)
  if '$isobject(project) {
    // Nothing found, we are safe to create a new one.
    set project = ##class(%Studio.Project).%New()
    set project.Name = name
    
    // Save the project to make sure it exists even if empty.
    do project.%Save()
  }
    
  // Now load the relationship data into the memory.
  do project.Items.Load()
  return project
]]></Implementation>
</Method>

<Method name="CompileProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,qspec:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)

  $$$QuitOnError(..AssertValidProject(name, .project))
  return project.Compile(qspec)
]]></Implementation>
</Method>

<Method name="DeleteProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)

  $$$ThrowOnError(..AssertValidProject(name, .project))
  $$$ThrowOnError(##class(%Studio.Project).Delete(name))
]]></Implementation>
</Method>

<Method name="ExportProjectToXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)

  set tempFilename = ##class(%File).TempFilename("xml")

  $$$ThrowOnError(..AssertValidProject(name, .project))
  $$$ThrowOnError(project.Export(tempFilename, "/nodisplay/diffexport", 0,.errors))

  set input = ##class(%Stream.FileCharacter).%New()
  set input.TranslateTable = ##class(Port.Configuration).GetPublicFileOutputTranslateTable()
  $$$ThrowOnError(input.LinkToFile(tempFilename))

  set output = ##class(%Stream.GlobalCharacter).%New()
  set input.TranslateTable = ##class(Port.Configuration).GetPublicFileOutputTranslateTable()
  $$$ThrowOnError(output.CopyFrom(input))

  set input = ""
  do ##class(%File).Delete(tempFilename)

  return output
]]></Implementation>
</Method>

<Method name="GetDocumentReferences">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,expression:%String,pattern:%String,includeSystemDocs:%Boolean=1,wholeWords:%Boolean=0,caseSensitive:%Boolean=0,max:%Integer=50,filter:%String="",wild:%Boolean=0</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  $$$ThrowOnError(##class(Frontier.Shared.Utilities).CallAndCapture("%Studio.Project", "FindInFiles", .output, expression, pattern, includeSystemDocs, wholeWords, caseSensitive, max, filter, wild))
  return output
]]></Implementation>
</Method>

<Method name="RetrieveItemSourceCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,itemName:%String,*isBinary:%Boolean=""</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  #dim stream As %Stream.GlobalCharacter
  set code = []
  set isBinary = 0

  set externalPath = ##class(Port.Util).ItemToPath(itemName)
  set pathType = ##class(Port.Util).GetPathType($$$LPadSlash(externalPath))
  
  set publicFileOTT = ##class(Port.Configuration).GetPublicFileOutputTranslateTable()  
  set routineOTT = ##class(Port.Configuration).GetRoutineOutputTranslateTable()
  
  $$$ChangeNamespace(namespace)

  if pathType = "CLS" {
    $$$ThrowOnError(##class(%Compiler.UDL.TextServices).GetTextAsStream(namespace, itemName, .content))
    set code = $$StreamToArray(content)
  } elseif ##class(Port.Util).IsRoutine(itemName) {    
    set routine = ##class(%RoutineMgr).%OpenId(itemName)
    if '$isobject(routine) $$$ThrowStatus($$$ERROR($$$RoutineDoesNotExist, itemName))
    set code = $$StreamToArray(routine.Code)
  } else {
    set ext = $$$ucase($piece(itemName, ".", *))
    set csp = ##class(%CSP.Routine).%New($$$LPadProvidedSlash(itemName, "/"))
    set isBinary = $select(isBinary '= "" : isBinary, 1: ..IsBinary(ext))       
    
    if 'isBinary {
      set csp.TranslateTable = publicFileOTT
    } else {
      set csp.TranslateTable = "RAW"
    }         
    set code = $$StreamToArray(csp)
  }

  return code

StreamToArray(stream)
  set array = []

  do stream.Rewind()
  set len = 12000 

  while 'stream.AtEnd {
    if 'isBinary {
      do array.%Push(stream.ReadLine())
    } else {
      do array.%Push($System.Encryption.Base64Encode(stream.Read(.len), 1))
    }
  }
  return array
]]></Implementation>
</Method>

<Method name="RepairProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<Implementation><![CDATA[
  $$$ChangeNamespace(namespace)
  $$$ThrowOnError(..AssertValidProject(name, .project))
  $$$ThrowOnError(project.Check())
  $$$ThrowOnError(project.%Save())
]]></Implementation>
</Method>

<Method name="AssertValidProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,*project:%Studio.Project=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set project = ##class(%Studio.Project).%OpenId(name)
  if '$isobject(project) $$$ThrowStatus($$$ERROR($$$GeneralError, $$$FormatText("Project '%1' does not exist.", name)))
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Routine name="xport" type="INC"><![CDATA[
#define StatusToException(%sc)  ##class(%Exception.StatusException).CreateFromStatus(%sc)
#define ContinueOnError(%sc) set sc = %sc continue:$$$ISERR(sc)
#define ReturnOnError(%sc) set sc = %sc return:$$$ISERR(sc) sc
#define AddAndContinue(%sc) set cSC = %sc set sc = $$$ADDSC(sc, cSC) continue:$$$ISERR(cSC)
#define ChangeNamespace(%ns) new $namespace try { set $namespace = %ns } catch ex { $$$ThrowStatus($$$ERROR($$$GeneralError, "Invalid namespace "_%ns_".")) }
#define CheckLegacySourceControl(%legacy) if %legacy = 1 $$$ThrowOnError(##class(%Studio.SourceControl.Interface).SourceControlCreate($username,"",.created,.flags,.username,"",.reload,"",.iconStatus))
]]></Routine>
</Export>
